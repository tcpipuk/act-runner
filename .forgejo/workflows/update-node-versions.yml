name: Update Node.js Versions

# This workflow automatically maintains Node.js versions in our build matrix.
#
# Design constraints:
# - Each build includes exactly 2 Node.js versions (overlapping pairs for smooth transitions)
# - Only includes versions currently in Active or Maintenance support
# - Updates tag aliases (edge/latest/lts) to match Node.js official designations
# - Uses regex instead of YAML parsing to preserve comments and formatting
# - Python code embedded in workflow (not separate script) for security

on:
  schedule:
    # Run daily at 5am UTC (after the nightly build at 4am)
    - cron: '0 5 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - check for updates without creating PR'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

jobs:
  check-node-updates:
    name: Check for Node.js Updates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.FORGEJO_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Check Node.js versions and create update
        id: check-versions
        run: |
          python3 <<'EOF'
          import json
          import urllib.request
          import re
          from datetime import datetime
          import os
          import sys

          # Fetch Node.js release schedule
          def get_node_releases():
              url = "https://raw.githubusercontent.com/nodejs/Release/main/schedule.json"
              with urllib.request.urlopen(url) as response:
                  return json.loads(response.read())

          # Check if a version is currently supported and released
          def is_supported(version_info, today):
              # Must have both start and end dates
              if 'start' not in version_info or 'end' not in version_info:
                  return False

              start_date = datetime.strptime(version_info['start'], '%Y-%m-%d')
              end_date = datetime.strptime(version_info['end'], '%Y-%m-%d')

              # Version must be released (start date has passed) and still supported
              return start_date <= today < end_date

          # Get the major version number
          def get_major_version(version_str):
              # Handle both 'v18' and '18' formats
              version = version_str.replace('v', '')
              # Handle old versions like 0.8, 0.10, 0.12 - use second part as major
              if version.startswith('0.'):
                  return int(version.split('.')[1])
              return int(version)

          # Main logic
          today = datetime.now()
          releases = get_node_releases()

          # Filter supported versions
          supported_versions = []
          lts_versions = []  # Track ALL LTS versions
          current_version = None

          for version, info in releases.items():
              major = get_major_version(version)
              # Only include even-numbered versions (stable releases)
              # Odd-numbered versions are development/unstable
              if is_supported(info, today) and major % 2 == 0:
                  supported_versions.append(major)

                  # Track ALL LTS versions
                  if 'lts' in info and info['lts'] and info['lts'] != False:
                      # Check if LTS has already started
                      lts_start = datetime.strptime(info['lts'], '%Y-%m-%d') if isinstance(info['lts'], str) else today
                      if lts_start <= today:
                          lts_versions.append(major)

                  # Current is the highest supported version
                  if not current_version or major > current_version:
                      current_version = major

          # Sort versions in ascending order
          supported_versions.sort()
          lts_versions.sort()

          print(f"Supported Node.js versions: {supported_versions}")
          print(f"LTS versions: {lts_versions}")
          print(f"Current (latest): v{current_version}")

          # Generate version pairs (each build includes 2 versions)
          # We want overlapping pairs to ensure smooth transitions
          version_pairs = []
          for i in range(len(supported_versions) - 1):
              pair = f"{supported_versions[i]}+{supported_versions[i+1]}"
              version_pairs.append(pair)

          print(f"Generated version pairs: {version_pairs}")

          # Determine tag aliases
          # edge = newest pair (highest versions)
          # latest = pair of two newest LTS versions
          # lts = pair of two oldest LTS versions

          tag_aliases = {}

          if version_pairs:
              # Edge is always the newest pair
              edge_pair = version_pairs[-1]
              tag_aliases['edge'] = {
                  'ubuntu': '25.04',
                  'node_versions': edge_pair,
                  'python': '3.13'
              }

              # Build LTS-only pairs if we have LTS versions
              if len(lts_versions) >= 2:
                  # LTS: pair of two oldest LTS versions
                  lts_pair = f"{lts_versions[0]}+{lts_versions[1]}"
                  if lts_pair in version_pairs:
                      tag_aliases['lts'] = {
                          'ubuntu': '22.04',
                          'node_versions': lts_pair,
                          'python': '3.13'
                      }

                  # Latest: pair of two newest LTS versions
                  latest_pair = f"{lts_versions[-2]}+{lts_versions[-1]}"
                  if latest_pair in version_pairs:
                      tag_aliases['latest'] = {
                          'ubuntu': '24.04',
                          'node_versions': latest_pair,
                          'python': '3.13'
                      }
              elif len(lts_versions) == 1:
                  # Only one LTS version, find the pair containing it
                  for pair in version_pairs:
                      if str(lts_versions[0]) in pair.split('+'):
                          tag_aliases['lts'] = {
                              'ubuntu': '22.04',
                              'node_versions': pair,
                              'python': '3.13'
                          }
                          tag_aliases['latest'] = {
                              'ubuntu': '24.04',
                              'node_versions': pair,
                              'python': '3.13'
                          }
                          break

          # Read current build.yml
          with open('.forgejo/workflows/build.yml', 'r') as f:
              content = f.read()

          # Extract current version pairs from the matrix using regex
          matrix_pattern = r'node_versions:\s*\[(.*?)\]'
          match = re.search(matrix_pattern, content)
          if match:
              current_pairs_str = match.group(1)
              # Parse the quoted strings
              current_pairs = re.findall(r'"([^"]+)"', current_pairs_str)
          else:
              current_pairs = []

          print(f"Current version pairs in build.yml: {current_pairs}")
          print(f"New version pairs needed: {version_pairs}")

          # Check if update is needed
          pairs_changed = set(current_pairs) != set(version_pairs)

          if pairs_changed:
              print("Update required!")

              # Generate the new matrix line
              new_matrix_line = 'node_versions: [' + ', '.join(f'"{p}"' for p in version_pairs) + ']'

              # Update the build.yml content
              updated_content = re.sub(
                  r'node_versions:\s*\[.*?\]',
                  new_matrix_line,
                  content
              )

              # Update tag aliases in the include section
              # This is more complex as we need to update the specific entries

              # Function to update a tag alias entry
              def update_tag_alias(content, alias_name, config):
                  # More flexible pattern that handles whitespace variations
                  # Matches the include block with this specific tag_alias
                  pattern = (
                      r'- ubuntu:\s*"[^"]+"\s*\n'
                      r'\s*node_versions:\s*"[^"]+"\s*\n'
                      r'\s*python:\s*"[^"]+"\s*\n'
                      r'\s*tag_alias:\s*"' + alias_name + r'"'
                  )

                  # Preserve indentation from original
                  replacement = (
                      f'- ubuntu: "{config["ubuntu"]}"\n'
                      f'            node_versions: "{config["node_versions"]}"\n'
                      f'            python: "{config["python"]}"\n'
                      f'            tag_alias: "{alias_name}"'
                  )

                  # Check if this alias exists
                  if re.search(pattern, content, re.MULTILINE):
                      content = re.sub(pattern, replacement, content, flags=re.MULTILINE)
                  else:
                      print(f"Warning: Could not find {alias_name} alias in build.yml")
                      print(f"Manual update may be required for {alias_name} tag alias")

                  return content

              # Update each tag alias
              for alias_name, config in tag_aliases.items():
                  updated_content = update_tag_alias(updated_content, alias_name, config)

              # Update README.md alias table
              def update_readme_aliases(readme_content, tag_aliases):
                  for alias_name, config in tag_aliases.items():
                      # Build the full image tag
                      ubuntu_short = config['ubuntu'].replace('.', '')
                      node_tag = config['node_versions'].replace('+', '-')
                      py_tag = config['python'].replace('.', '')
                      full_tag = f"ubuntu{ubuntu_short}-node{node_tag}-py{py_tag}"

                      # Determine description based on alias
                      if alias_name == 'edge':
                          desc = f"Bleeding edge - Ubuntu {config['ubuntu']}, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"
                      elif alias_name == 'latest':
                          desc = f"Current stable - Ubuntu {config['ubuntu']} LTS, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"
                      elif alias_name == 'lts':
                          desc = f"Previous LTS - Ubuntu {config['ubuntu']} LTS, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"

                      # Pattern to match the table row for this alias
                      pattern = rf'\| \*\*\[`{alias_name}`\][^\|]+\| [^\|]+ \| \[`[^`]+`\][^\|]+\|'

                      replacement = (
                          f'| **[`{alias_name}`](https://git.tomfos.tr/tom/-/packages/container/act-runner/{alias_name})**'
                          f' | {desc}'
                          f' | [`{full_tag}`](https://git.tomfos.tr/tom/-/packages/container/act-runner/{full_tag}) |'
                      )

                      if re.search(pattern, readme_content):
                          readme_content = re.sub(pattern, replacement, readme_content)
                      else:
                          print(f"Warning: Could not find {alias_name} alias in README.md")

                  return readme_content

              # Write the updated files if not in dry run mode
              dry_run = os.environ.get('DRY_RUN', 'false').lower() == 'true'

              if not dry_run:
                  with open('.forgejo/workflows/build.yml', 'w') as f:
                      f.write(updated_content)
                  print("Updated build.yml")

                  # Update README.md
                  with open('README.md', 'r') as f:
                      readme_content = f.read()

                  updated_readme = update_readme_aliases(readme_content, tag_aliases)

                  with open('README.md', 'w') as f:
                      f.write(updated_readme)
                  print("Updated README.md")
              else:
                  print("DRY RUN - Would update build.yml")

              # Set outputs for the next steps
              print(f"::set-output name=update_needed::true")
              print(f"::set-output name=old_versions::{','.join(current_pairs)}")
              print(f"::set-output name=new_versions::{','.join(version_pairs)}")
              print(f"::set-output name=supported_versions::{','.join(str(v) for v in supported_versions)}")

          else:
              print("No update needed - versions are current")
              print(f"::set-output name=update_needed::false")

          EOF

          # Set environment variable for dry run if specified
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
              export DRY_RUN=true
          fi

      - name: Create Pull Request
        if: steps.check-versions.outputs.update_needed == 'true' && github.event.inputs.dry_run != 'true'
        run: |
          # Configure git with token authentication
          git config --local user.email "git@tomfos.tr"
          git config --local user.name "Forgejo Actions"

          # Set up authentication for push
          git remote set-url origin https://${{ secrets.FORGEJO_TOKEN }}@git.tomfos.tr/tom/act-runner.git

          # Use a consistent branch name for all version updates
          BRANCH_NAME="update-node-versions"

          # Check if the branch exists on remote
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
              echo "Branch exists, updating existing PR"
              git fetch origin "$BRANCH_NAME"
              git checkout "$BRANCH_NAME"
              git reset --hard origin/main  # Start fresh from main
          else
              echo "Creating new branch for PR"
              git checkout -b "$BRANCH_NAME"
          fi

          # Commit changes
          git add .forgejo/workflows/build.yml README.md
          git commit -m "Update Node.js versions

          - Previous: ${{ steps.check-versions.outputs.old_versions }}
          - New: ${{ steps.check-versions.outputs.new_versions }}"

          # Push the branch (force-with-lease is safer - fails if branch was manually modified)
          git push --force-with-lease origin "$BRANCH_NAME"

          # Create PR if it doesn't exist, otherwise it auto-updates
          # Check if PR already exists
          PR_EXISTS=$(gh pr list --head "$BRANCH_NAME" --state open --json number --jq '.[0].number' || echo "")

          if [ -z "$PR_EXISTS" ]; then
              echo "Creating new PR"
              gh pr create \
                --title "Update Node.js versions" \
                --body "### Automated Node.js Version Update

          - **Previous versions**: ${{ steps.check-versions.outputs.old_versions }}
          - **New versions**: ${{ steps.check-versions.outputs.new_versions }}
          - **Supported versions**: ${{ steps.check-versions.outputs.supported_versions }}

          This PR is automatically updated when Node.js versions change." \
                --base main \
                --head "$BRANCH_NAME"
          else
              echo "PR #$PR_EXISTS already exists and will be updated with new commit"
          fi

      - name: Summary
        if: always()
        run: |
          echo "## Node.js Version Check Summary" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.check-versions.outputs.update_needed }}" == "true" ]]; then
            echo "✅ **Update Required**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- Previous: ${{ steps.check-versions.outputs.old_versions }}" >> $GITHUB_STEP_SUMMARY
            echo "- New: ${{ steps.check-versions.outputs.new_versions }}" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "⚠️ **Dry run mode** - No PR was created" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "✅ **No update needed** - Node.js versions are current" >> $GITHUB_STEP_SUMMARY
          fi

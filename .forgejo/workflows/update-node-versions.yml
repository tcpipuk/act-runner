name: Update Node.js Versions

# This workflow automatically maintains Node.js versions in our build matrix.
#
# Design constraints:
# - Each build includes exactly 2 Node.js versions (overlapping pairs for smooth transitions)
# - Only includes versions currently in Active or Maintenance support
# - Updates tag aliases (edge/latest/lts) to match Node.js official designations
# - Uses regex instead of YAML parsing to preserve comments and formatting
# - Python code embedded in workflow (not separate script) for security

on:
  push:
    branches:
      - main
    paths:
      - '.forgejo/workflows/update-node-versions.yml'
  schedule:
    # Run daily at 5am UTC (after the nightly build at 4am)
    - cron: '0 5 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run - check for updates without creating PR'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

jobs:
  check-node-updates:
    name: Check for Node.js Updates
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.FORGEJO_TOKEN }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Check Node.js versions and create update
        id: check-versions
        run: |
          python3 <<'EOF'
          import json
          import urllib.request
          import re
          from datetime import datetime
          import os
          import sys

          # Fetch Node.js release schedule
          def get_node_releases():
              url = "https://raw.githubusercontent.com/nodejs/Release/main/schedule.json"
              with urllib.request.urlopen(url) as response:
                  return json.loads(response.read())

          # Check if a version is currently supported and released
          def is_supported(version_info, today):
              # Must have both start and end dates
              if 'start' not in version_info or 'end' not in version_info:
                  return False

              start_date = datetime.strptime(version_info['start'], '%Y-%m-%d')
              end_date = datetime.strptime(version_info['end'], '%Y-%m-%d')

              # Version must be released (start date has passed) and still supported
              return start_date <= today < end_date

          # Get the major version number
          def get_major_version(version_str):
              # Handle both 'v18' and '18' formats
              version = version_str.replace('v', '')
              # Handle old versions like 0.8, 0.10, 0.12 - use second part as major
              if version.startswith('0.'):
                  return int(version.split('.')[1])
              return int(version)

          # Main logic
          today = datetime.now()
          releases = get_node_releases()

          # Filter supported versions
          supported_versions = []
          lts_versions = []  # Track ALL LTS versions
          current_version = None

          for version, info in releases.items():
              major = get_major_version(version)
              # Only include even-numbered versions (stable releases)
              # Odd-numbered versions are development/unstable
              if is_supported(info, today) and major % 2 == 0:
                  supported_versions.append(major)

                  # Track ALL LTS versions
                  if 'lts' in info and info['lts'] and info['lts'] != False:
                      # Check if LTS has already started
                      lts_start = datetime.strptime(info['lts'], '%Y-%m-%d') if isinstance(info['lts'], str) else today
                      if lts_start <= today:
                          lts_versions.append(major)

                  # Current is the highest supported version
                  if not current_version or major > current_version:
                      current_version = major

          # Sort versions in ascending order
          supported_versions.sort()
          lts_versions.sort()

          print(f"Supported Node.js versions: {supported_versions}")
          print(f"LTS versions: {lts_versions}")
          print(f"Current (latest): v{current_version}")

          # Generate version pairs (each build includes 2 versions)
          # We want overlapping pairs to ensure smooth transitions
          version_pairs = []
          for i in range(len(supported_versions) - 1):
              pair = f"{supported_versions[i]}+{supported_versions[i+1]}"
              version_pairs.append(pair)

          print(f"Generated version pairs: {version_pairs}")

          # Determine tag aliases
          # edge = newest pair (highest versions)
          # latest = pair of two newest LTS versions
          # lts = pair of two oldest LTS versions

          tag_aliases = {}

          if version_pairs:
              # Edge is always the newest pair
              edge_pair = version_pairs[-1]
              tag_aliases['edge'] = {
                  'ubuntu': '25.04',
                  'node_versions': edge_pair,
                  'python': '3.13'
              }

              # Build LTS-only pairs if we have LTS versions
              if len(lts_versions) >= 2:
                  # LTS: pair of two oldest LTS versions
                  lts_pair = f"{lts_versions[0]}+{lts_versions[1]}"
                  if lts_pair in version_pairs:
                      tag_aliases['lts'] = {
                          'ubuntu': '22.04',
                          'node_versions': lts_pair,
                          'python': '3.13'
                      }

                  # Latest: pair of two newest LTS versions
                  latest_pair = f"{lts_versions[-2]}+{lts_versions[-1]}"
                  if latest_pair in version_pairs:
                      tag_aliases['latest'] = {
                          'ubuntu': '24.04',
                          'node_versions': latest_pair,
                          'python': '3.13'
                      }
              elif len(lts_versions) == 1:
                  # Only one LTS version, find the pair containing it
                  for pair in version_pairs:
                      if str(lts_versions[0]) in pair.split('+'):
                          tag_aliases['lts'] = {
                              'ubuntu': '22.04',
                              'node_versions': pair,
                              'python': '3.13'
                          }
                          tag_aliases['latest'] = {
                              'ubuntu': '24.04',
                              'node_versions': pair,
                              'python': '3.13'
                          }
                          break

          # Read current build.yml
          with open('.forgejo/workflows/build.yml', 'r') as f:
              content = f.read()

          # Extract current version pairs from the matrix using regex
          matrix_pattern = r'node_versions:\s*\[(.*?)\]'
          match = re.search(matrix_pattern, content)
          if match:
              current_pairs_str = match.group(1)
              # Parse the quoted strings
              current_pairs = re.findall(r'"([^"]+)"', current_pairs_str)
          else:
              current_pairs = []

          print(f"Current version pairs in build.yml: {current_pairs}")
          print(f"New version pairs needed: {version_pairs}")

          # Check if update is needed
          pairs_changed = set(current_pairs) != set(version_pairs)

          if pairs_changed:
              print("Update required!")

              # Generate the new matrix line
              new_matrix_line = 'node_versions: [' + ', '.join(f'"{p}"' for p in version_pairs) + ']'

              # Update the build.yml content
              updated_content = re.sub(
                  r'node_versions:\s*\[.*?\]',
                  new_matrix_line,
                  content
              )

              # Update tag aliases in the include section
              # This is more complex as we need to update the specific entries

              # Function to update a tag alias entry
              def update_tag_alias(content, alias_name, config):
                  # More flexible pattern that handles whitespace variations
                  # Matches the include block with this specific tag_alias
                  pattern = (
                      r'- ubuntu:\s*"[^"]+"\s*\n'
                      r'\s*node_versions:\s*"[^"]+"\s*\n'
                      r'\s*python:\s*"[^"]+"\s*\n'
                      r'\s*tag_alias:\s*"' + alias_name + r'"'
                  )

                  # Preserve indentation from original
                  replacement = (
                      f'- ubuntu: "{config["ubuntu"]}"\n'
                      f'            node_versions: "{config["node_versions"]}"\n'
                      f'            python: "{config["python"]}"\n'
                      f'            tag_alias: "{alias_name}"'
                  )

                  # Check if this alias exists
                  if re.search(pattern, content, re.MULTILINE):
                      content = re.sub(pattern, replacement, content, flags=re.MULTILINE)
                  else:
                      print(f"Warning: Could not find {alias_name} alias in build.yml")
                      print(f"Manual update may be required for {alias_name} tag alias")

                  return content

              # Update each tag alias
              for alias_name, config in tag_aliases.items():
                  updated_content = update_tag_alias(updated_content, alias_name, config)

              # Update README.md alias table
              def update_readme_aliases(readme_content, tag_aliases):
                  for alias_name, config in tag_aliases.items():
                      # Build the full image tag (keep dots in versions)
                      node_tag = config['node_versions'].replace('+', '-')
                      full_tag = f"ubuntu{config['ubuntu']}-node{node_tag}-py{config['python']}"

                      # Determine description based on alias
                      if alias_name == 'edge':
                          desc = f"Bleeding edge - Ubuntu {config['ubuntu']}, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"
                      elif alias_name == 'latest':
                          desc = f"Current stable - Ubuntu {config['ubuntu']} LTS, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"
                      elif alias_name == 'lts':
                          desc = f"Previous LTS - Ubuntu {config['ubuntu']} LTS, Node.js {config['node_versions'].replace('+', '/')}, Python {config['python']}"

                      # Pattern to match the table row for this alias
                      pattern = rf'\| \*\*\[`{alias_name}`\][^\|]+\| [^\|]+ \| \[`[^`]+`\][^\|]+\|'

                      replacement = (
                          f'| **[`{alias_name}`](https://git.tomfos.tr/tom/-/packages/container/act-runner/{alias_name})**'
                          f' | {desc}'
                          f' | [`{full_tag}`](https://git.tomfos.tr/tom/-/packages/container/act-runner/{full_tag}) |'
                      )

                      if re.search(pattern, readme_content):
                          readme_content = re.sub(pattern, replacement, readme_content)
                      else:
                          print(f"Warning: Could not find {alias_name} alias in README.md")

                  return readme_content

              # Generate the available images table based on build matrix
              def generate_images_table(updated_content):
                  """Generate the available images table from the build.yml matrix."""
                  # Parse build.yml to extract matrix values
                  ubuntu_pattern = r'ubuntu:\s*\[(.+?)\]'
                  node_pattern = r'node_versions:\s*\[(.+?)\]'
                  python_pattern = r'python:\s*\[(.+?)\]'

                  ubuntu_match = re.search(ubuntu_pattern, updated_content)
                  node_match = re.search(node_pattern, updated_content)
                  python_match = re.search(python_pattern, updated_content)

                  if not all([ubuntu_match, node_match, python_match]):
                      print("Warning: Could not parse matrix values from build.yml")
                      return None

                  # Extract and clean the values
                  ubuntu_versions = [v.strip().strip('"') for v in ubuntu_match.group(1).split(',')]
                  node_versions = [v.strip().strip('"') for v in node_match.group(1).split(',')]
                  python_versions = [v.strip().strip('"') for v in python_match.group(1).split(',')]

                  # Build the table
                  table_lines = []
                  table_lines.append("| Ubuntu | Node.js | Python Versions Available |")
                  table_lines.append("|--------|---------|---------------------------|")

                  # Process each Ubuntu version
                  for ubuntu in sorted(ubuntu_versions, reverse=True):
                      ubuntu_display = f"{ubuntu} LTS" if ubuntu in ["22.04", "24.04"] else ubuntu

                      # Add node version rows
                      for node_pair in sorted(node_versions, reverse=True):
                          node_display = node_pair.replace('+', ', ')
                          node_tag = node_pair.replace('+', '-')

                          # Build Python version links
                          python_links = []

                          # Add base node image (no Python)
                          base_url = f"https://git.tomfos.tr/tom/-/packages/container/act-runner/ubuntu{ubuntu}-node{node_tag}"
                          python_links.append(f"[None]({base_url})")

                          # Add Python variants
                          for py_ver in sorted(python_versions, reverse=True):
                              # Skip Python 3.11 for Ubuntu 25.04
                              if ubuntu == "25.04" and py_ver == "3.11":
                                  continue
                              py_url = f"https://git.tomfos.tr/tom/-/packages/container/act-runner/ubuntu{ubuntu}-node{node_tag}-py{py_ver}"
                              python_links.append(f"[{py_ver}]({py_url})")

                          python_cell = ", ".join(python_links)
                          table_lines.append(f"| {ubuntu_display} | {node_display} | {python_cell} |")

                      # Add base image row (no Node.js)
                      base_url = f"https://git.tomfos.tr/tom/-/packages/container/act-runner/ubuntu{ubuntu}-base"
                      table_lines.append(f"| {ubuntu_display} | None | [None]({base_url}) |")

                  return "\n".join(table_lines)

              # Write the updated files if not in dry run mode
              dry_run = os.environ.get('DRY_RUN', 'false').lower() == 'true'

              if not dry_run:
                  with open('.forgejo/workflows/build.yml', 'w') as f:
                      f.write(updated_content)
                  print("Updated build.yml")

                  # Update README.md
                  with open('README.md', 'r') as f:
                      readme_content = f.read()

                  updated_readme = update_readme_aliases(readme_content, tag_aliases)

                  # Regenerate the available images table
                  new_table = generate_images_table(updated_content)
                  if new_table:
                      # Find and replace the table section
                      table_pattern = r'(\| Ubuntu \| Node\.js \| Python Versions Available \|\n\|[-]+\|[-]+\|[-]+\|(?:\n\|[^\n]+)*)'
                      if re.search(table_pattern, updated_readme):
                          updated_readme = re.sub(table_pattern, new_table, updated_readme)
                          print("Regenerated available images table")
                      else:
                          print("Warning: Could not find images table in README.md")

                  with open('README.md', 'w') as f:
                      f.write(updated_readme)
                  print("Updated README.md")
              else:
                  print("DRY RUN - Would update build.yml")

              # Set outputs for the next steps
              print(f"::set-output name=update_needed::true")
              print(f"::set-output name=old_versions::{','.join(current_pairs)}")
              print(f"::set-output name=new_versions::{','.join(version_pairs)}")
              print(f"::set-output name=supported_versions::{','.join(str(v) for v in supported_versions)}")

          else:
              print("No update needed - versions are current")
              print(f"::set-output name=update_needed::false")

          EOF

          # Set environment variable for dry run if specified
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
              export DRY_RUN=true
          fi

      - name: Create Pull Request
        if: steps.check-versions.outputs.update_needed == 'true' && github.event.inputs.dry_run != 'true'
        run: |
          # Configure git with token authentication
          git config --local user.email "git@tomfos.tr"
          git config --local user.name "Forgejo Actions"

          # Set up authentication for push
          REPO_URL="${{ github.server_url }}/${{ github.repository }}.git"
          git remote set-url origin https://${{ secrets.FORGEJO_TOKEN }}@${REPO_URL#https://}

          # Use a consistent branch name for all version updates
          BRANCH_NAME="update-node-versions"

          echo "ðŸ”„ Preparing update branch..."
          echo ""

          # Check if the branch exists on remote
          if git ls-remote --heads origin "$BRANCH_NAME" 2>/dev/null | grep -q "$BRANCH_NAME"; then
              echo "ðŸ“Œ Found existing branch '$BRANCH_NAME'"
              # Stash our changes before switching branches
              git stash push -m "Node.js version updates" --quiet
              git fetch origin "$BRANCH_NAME" --quiet
              git checkout "$BRANCH_NAME" --quiet
              git reset --hard origin/main --quiet  # Start fresh from main
              # Apply our stashed changes
              git stash pop --quiet
              echo "âœ“ Branch updated from main"
          else
              echo "ðŸŒ¿ Creating new branch '$BRANCH_NAME'"
              git checkout -b "$BRANCH_NAME" --quiet
              echo "âœ“ Branch created"
          fi

          echo ""
          echo "ðŸ“ Committing changes..."
          # Commit changes
          git add .forgejo/workflows/build.yml README.md
          git commit --quiet -m "Update Node.js versions

          - Previous: ${{ steps.check-versions.outputs.old_versions }}
          - New: ${{ steps.check-versions.outputs.new_versions }}"
          echo "âœ“ Changes committed"

          echo ""
          echo "â¬†ï¸ Pushing to remote..."
          # Push the branch (force-with-lease is safer - fails if branch was manually modified)
          git push --force-with-lease origin "$BRANCH_NAME" 2>&1 | grep -v "remote:" | grep -v "Create a new pull" || true
          echo "âœ“ Branch pushed to origin"

          echo ""

          # Create PR if it doesn't exist using Forgejo API
          python3 <<'EOF'
          import json
          import urllib.request
          import urllib.error
          import os

          token = "${{ secrets.FORGEJO_TOKEN }}"
          api_base = "${{ github.server_url }}/api/v1"  # e.g. https://git.tomfos.tr/api/v1
          repo = "${{ github.repository }}"  # e.g. tom/act-runner
          branch_name = "update-node-versions"

          print("ðŸ” Checking for existing pull requests...")

          # Check if PR already exists
          headers = {"Authorization": f"token {token}"}
          req = urllib.request.Request(
              f"{api_base}/repos/{repo}/pulls?state=open",
              headers=headers
          )

          try:
              with urllib.request.urlopen(req) as response:
                  pulls = json.loads(response.read())

                  # Find PR from our branch
                  existing_pr = None
                  for pr in pulls:
                      if pr.get('head', {}).get('ref', '') == branch_name:
                          existing_pr = pr
                          break

                  if existing_pr:
                      print(f"âœ… PR #{existing_pr['number']} already exists and was updated")
                      print(f"   {existing_pr.get('html_url', 'N/A')}")
                  else:
                      # Create new PR
                      print("ðŸ“‹ Creating new pull request...")
                      pr_body = "### Automated Node.js Version Update\n\n"
                      pr_body += "* **Previous versions**: ${{ steps.check-versions.outputs.old_versions }}\n"
                      pr_body += "* **New versions**: ${{ steps.check-versions.outputs.new_versions }}\n"
                      pr_body += "* **Supported versions**: ${{ steps.check-versions.outputs.supported_versions }}\n\n"
                      pr_body += "This PR is automatically updated when Node.js versions change."

                      pr_data = {
                          "title": "Update Node.js versions",
                          "head": "update-node-versions",
                          "base": "main",
                          "body": pr_body
                      }

                      req = urllib.request.Request(
                          f"{api_base}/repos/{repo}/pulls",
                          data=json.dumps(pr_data).encode('utf-8'),
                          headers={**headers, "Content-Type": "application/json"},
                          method='POST'
                      )

                      with urllib.request.urlopen(req) as response:
                          new_pr = json.loads(response.read())
                          print(f"âœ… Created PR #{new_pr['number']}")
                          print(f"   {new_pr.get('html_url', 'N/A')}")

          except urllib.error.HTTPError as e:
              print(f"Error: {e.code} - {e.reason}")
              print(e.read().decode('utf-8'))
              exit(1)
          EOF

      - name: Summary
        if: always()
        run: |
          echo "## Node.js Version Check Summary" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.check-versions.outputs.update_needed }}" == "true" ]]; then
            echo "âœ… **Update Required**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- Previous: ${{ steps.check-versions.outputs.old_versions }}" >> $GITHUB_STEP_SUMMARY
            echo "- New: ${{ steps.check-versions.outputs.new_versions }}" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "âš ï¸ **Dry run mode** - No PR was created" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âœ… **No update needed** - Node.js versions are current" >> $GITHUB_STEP_SUMMARY
          fi
